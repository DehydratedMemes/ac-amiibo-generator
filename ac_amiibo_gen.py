#!/usr/bin/env python3
"""
Animal Crossing Amiibo Generator for emuiibo
============================================

This script generates virtual Amiibos for use with 'emuiibo' on Nintendo Switch.
It fetches data from the AmiiboAPI and community translations, allowing for
customized, localized Amiibo generation.

Features:
- Filter by Animal Crossing series.
- Localize villager names (e.g., Isabelle -> Canela).
- Randomize UUIDs (for unique registration).
- Download Amiibo images.
- CLI arguments or Interactive mode.

Author: Generated by Gemini (with user prompt)
License: GPLv2
"""

import os
import json
import random
import datetime
import shutil
import urllib.request
import re
import sys
import argparse

# Constants
AMIIBO_API_URL = "https://www.amiiboapi.com/api/amiibo/"
VILLAGERS_URL = "https://raw.githubusercontent.com/alexislours/translation-sheet-data/master/villagers.json"

# Available locales based on common game data
AVAILABLE_LOCALES = [
    "USen", "EUen", "USes", "EUes", "JPja", "KRko", 
    "EUde", "EUfr", "USfr", "EUit", "EUnl", "EUru", 
    "CNzh", "TWzh"
]

def download_json(url):
    """Downloads JSON data from a given URL."""
    print(f"[-] Downloading data from {url}...")
    try:
        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
        with urllib.request.urlopen(req) as response:
            return json.loads(response.read().decode())
    except Exception as e:
        print(f"[!] Error downloading {url}: {e}")
        return None

def reverse_ushort(val):
    """Swaps bytes for a 16-bit integer (Little Endian <-> Big Endian)."""
    return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF)

def parse_amiibo_id(head_hex, tail_hex):
    """
    Parses the Amiibo ID (Head + Tail) into emuiibo compatible JSON structure.
    
    Logic derived from emuiigen source code:
    - Head (4 bytes): Game Character ID (reversed), Character Variant (1 byte), Figure Type (1 byte)
    - Tail (4 bytes): Model Number (2 bytes, NOT reversed), Series (1 byte)
    """
    full_hex = head_hex + tail_hex
    
    # game_character_id: Bytes 0-1 (reversed)
    gc_id_hex = full_hex[0:4]
    gc_id_val = int(gc_id_hex, 16)
    game_character_id = reverse_ushort(gc_id_val)
    
    # character_variant: Byte 2
    character_variant = int(full_hex[4:6], 16)
    
    # figure_type: Byte 3
    figure_type = int(full_hex[6:8], 16)
    
    # model_number: Bytes 4-5 (NOT reversed)
    model_number = int(full_hex[8:12], 16)
    
    # series: Byte 6
    series = int(full_hex[12:14], 16)
    
    return {
        "game_character_id": game_character_id,
        "character_variant": character_variant,
        "figure_type": figure_type,
        "series": series,
        "model_number": model_number
    }

def get_localized_name(name_en, translations, target_locale):
    """
    Attempts to find the localized name for a villager.
    Falls back to the English name if not found.
    """
    if target_locale == "USen" or not translations:
        return name_en

    for entry in translations:
        # Check if entry has locale data
        if "locale" in entry and "USen" in entry["locale"]:
            # Match strictly by US English name
            if entry["locale"]["USen"] == name_en:
                if target_locale in entry["locale"]:
                    return entry["locale"][target_locale]
    
    return name_en

def sanitize_filename(name):
    """Sanitizes a string to be safe for use as a directory name."""
    # Remove characters invalid in file paths
    name = re.sub(r'[\\/*?:\"<>|]', "", name)
    # Remove trailing dots (issue on Windows)
    name = name.rstrip(".")
    return name.strip()

def produce_amiibo_name(base_name):
    """
    Compacts the name to fit within the 10-character limit of the internal Amiibo format.
    Removes spaces and punctuation to preserve as much meaning as possible.
    """
    name = base_name
    for ch in [' ', '-', '.', "'", "â€™"]:
        name = name.replace(ch, "")
    return name[:10]

def generate_random_uuid():
    """Generates a random 10-byte UUID."""
    return [random.randint(0, 255) for _ in range(10)]

def get_user_input(prompt, default=None, options=None):
    """Helper for interactive user input."""
    valid = False
    while not valid:
        opts_str = f" [{'/'.join(options)}]" if options else ""
        def_str = f" (default: {default})" if default else ""
        user_val = input(f"{prompt}{opts_str}{def_str}: ").strip()
        
        if not user_val and default is not None:
            return default
            
        if options:
            if user_val in options:
                return user_val
            else:
                print(f"[!] Invalid option. Please choose from: {', '.join(options)}")
        else:
            return user_val

def yes_no_prompt(prompt, default='y'):
    """Helper for Yes/No questions."""
    user_val = input(f"{prompt} (y/n) [default: {default}]: ").strip().lower()
    if not user_val:
        user_val = default
    return user_val.startswith('y')

def main():
    parser = argparse.ArgumentParser(description="Generate localized virtual Amiibos for Animal Crossing.")
    parser.add_argument("--locale", help=f"Target locale code (e.g., USes, EUen). Available: {', '.join(AVAILABLE_LOCALES)}")
    parser.add_argument("--out", help="Output directory path.")
    parser.add_argument("--no-images", action="store_true", help="Skip downloading Amiibo images.")
    parser.add_argument("--no-random-uuid", action="store_true", help="Do not randomize UUIDs (use standard generation).")
    parser.add_argument("--interactive", action="store_true", help="Force interactive mode.")
    
    args = parser.parse_args()

    # Determine configuration
    if args.interactive or (not args.locale and not args.out):
        print("\n=== Animal Crossing Amiibo Generator ===\n")
        
        # 1. Locale
        print("Available Locales:")
        for i, loc in enumerate(AVAILABLE_LOCALES):
            print(f"{loc.ljust(6)}", end="")
            if (i + 1) % 7 == 0: print()
        print("\n")
        
        locale = get_user_input("Select target locale", default="USes", options=AVAILABLE_LOCALES)
        
        # 2. Output Directory
        output_dir = get_user_input("Enter output directory", default="Amiibos")
        
        # 3. Images
        download_imgs = yes_no_prompt("Download Amiibo images?", default='y')
        
        # 4. Random UUID
        random_uuid = yes_no_prompt("Randomize UUIDs (Recommended for new registrations)?", default='y')
        
    else:
        # CLI Mode
        locale = args.locale if args.locale else "USes"
        if locale not in AVAILABLE_LOCALES:
            print(f"[!] Warning: '{locale}' is not a standard known locale, but proceeding anyway.")
            
        output_dir = args.out if args.out else "Amiibos"
        download_imgs = not args.no_images
        random_uuid = not args.no_random_uuid

    # --- Execution ---

    print("\n[+] Configuration:")
    print(f"    Locale:       {locale}")
    print(f"    Output Dir:   {output_dir}")
    print(f"    Images:       {'Yes' if download_imgs else 'No'}")
    print(f"    Random UUID:  {'Yes' if random_uuid else 'No'}")
    print("-" * 30)

    # 1. Fetch Data
    amiibo_data = download_json(AMIIBO_API_URL)
    if not amiibo_data:
        print("[!] Critical Error: Could not fetch Amiibo API data. Exiting.")
        return

    translations = []
    if locale != "USen":
        translations = download_json(VILLAGERS_URL)
        if not translations:
            print("[!] Warning: Translation data unavailable. Reverting to English names.")

    # 2. Prepare Output
    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
        except OSError as e:
            print(f"[!] Error creating directory {output_dir}: {e}")
            return

    # 3. Generate
    count = 0
    now = datetime.datetime.now()
    date_info = {"y": now.year, "m": now.month, "d": now.day}
    
    # Track processed names to handle duplicates (e.g. Cards vs Figures with same name)
    processed_names = set()

    total_entries = len(amiibo_data["amiibo"])
    print(f"[-] Processing {total_entries} entries...")

    for entry in amiibo_data["amiibo"]:
        # Filter for Animal Crossing only
        if entry["amiiboSeries"] != "Animal Crossing":
            continue

        original_name = entry["name"]
        
        # Localize Name
        final_name = get_localized_name(original_name, translations, locale)
        
        # Determine Directory Name
        clean_name = sanitize_filename(final_name)
        
        # Handle Naming Collisions (e.g., Isabelle card vs Isabelle figure)
        # We append the 'Head' ID part if the name is already taken to ensure unique folders.
        unique_name = clean_name
        if unique_name in processed_names:
            unique_name = f"{clean_name}_{entry['head']}"
        processed_names.add(unique_name)
        
        dir_path = os.path.join(output_dir, unique_name)
        
        # Create Folder
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)
        
        # Parse ID
        try:
            amiibo_id = parse_amiibo_id(entry["head"], entry["tail"])
        except ValueError:
            print(f"[!] Error parsing ID for {final_name}. Skipping.")
            continue
        
        # Compact name for JSON (max 10 chars)
        json_name = produce_amiibo_name(final_name)

        # Build JSON Structure
        amiibo_json = {
            "first_write_date": date_info,
            "id": amiibo_id,
            "last_write_date": date_info,
            "mii_charinfo_file": "mii-charinfo.bin",
            "name": json_name,
            "uuid": generate_random_uuid() if random_uuid else [0]*10, # Note: emuiibo might expect valid UUID or 0s
            "use_random_uuid": random_uuid,
            "version": 0,
            "write_counter": 0
        }
        
        # Save amiibo.json
        try:
            with open(os.path.join(dir_path, "amiibo.json"), "w", encoding='utf-8') as f:
                json.dump(amiibo_json, f, indent=4)
        except IOError as e:
            print(f"[!] Error writing JSON for {final_name}: {e}")
            continue
            
        # Save amiibo.flag (empty marker file)
        try:
            with open(os.path.join(dir_path, "amiibo.flag"), "w") as f:
                pass
        except IOError:
            pass

        # Download Image
        if download_imgs:
            image_url = entry["image"]
            try:
                req = urllib.request.Request(image_url, headers={'User-Agent': 'Mozilla/5.0'})
                with urllib.request.urlopen(req) as response, open(os.path.join(dir_path, "amiibo.png"), 'wb') as out_file:
                    shutil.copyfileobj(response, out_file)
            except Exception as e:
                # Non-critical error
                # print(f"[!] Image download failed for {final_name}: {e}")
                pass
        
        count += 1
        # Simple progress indicator
        sys.stdout.write(f"\r[+] Generated: {count} Amiibos")
        sys.stdout.flush()

    print(f"\n\n[SUCCESS] Generation complete! {count} virtual Amiibos saved to '{os.path.abspath(output_dir)}'.")

if __name__ == "__main__":
    main()